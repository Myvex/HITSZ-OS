diff --git a/Makefile b/Makefile
index b971308..3ef0516 100644
--- a/Makefile
+++ b/Makefile
@@ -157,6 +157,9 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_sleep\
+	$U/_pingpong\
+	$U/_find\
 
 
 ifeq ($(LAB),syscall)
diff --git a/commands.gdb b/commands.gdb
new file mode 100644
index 0000000..aae0f9b
--- /dev/null
+++ b/commands.gdb
@@ -0,0 +1,256 @@
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+s
+p cpus[$tp]->proc->name
+u 201
+p cpus[$tp]->proc->name
+p p->name
+finish
+b main.c:42
+c
+s
+u 431
+p p->name
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+q
+si 10
+q
+si
+si
+si
+si
+si
+b *0x80000086
+c
+u 58
+si
+u 29
+s
+u 201
+p p->name
+finish
+b main.c:42
+c
+s
+u 431
+p p->name
+n
+n
+si
+si
+si
+si
+finish
+u 469
+u 496
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+u 433
+q
+n
+p cpus[$tp]->proc->name
+n
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+n
+n
+n
+n
+n
+n
+nn
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+q
+si
+si
+si
+si
+si
+b *0x80000086
+c
+u 58
+i r mepc
+p main
+si
+u 29
+s
+n
+n
+n
+n
+n
+n
+n
+p p->name
+finish
+b main.c:42
+c
+s
+n
+n
+n
+n
+n
+n
+p p->name
+p cpus[$tp]->proc->name
+n
+n
+si
+si
+si
+si
+si 10
+si 10
+si 5
+si
+si
+si
+si
+n
+n
+n
+n
+n
+s
+p p->name
+n
+p p->name
+p cpus[$tp]->proc->name
+u 112
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si 10
+si 10
+si 10
+si
+si
+si
+si
+si
+p cpus[$tp]->proc->name
+si
+si
+si
+si
+si
+si
+i r stvec
+i r scause
+si
+ i r stvec
+si 10
+si 10
+si 10
+si
+si
+si
+si
+si
+si
+si
+si
+si
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+s
+p p->name
+n
+p p->name
+p cpus[$tp]->proc->name
+u 112
+da
+q
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..1ca2458
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,88 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+// 提取文件名的函数，返回路径中的最后一个 '/' 之后的部分
+char* fmtname(char *path) {
+    char *p;
+    for (p = path + strlen(path); p >= path && *p != '/'; p--)
+        ;
+    return p + 1;
+}
+
+// 递归查找函数
+void find(char *path, char *target) {
+    char buf[512], *p;
+    int fd;
+    struct dirent de;
+    struct stat st;
+
+    // 打开当前路径
+    if ((fd = open(path, 0)) < 0) {
+        fprintf(2, "find: cannot open %s\n", path);
+        return;
+    }
+
+    // 获取路径状态
+    if (fstat(fd, &st) < 0) {
+        fprintf(2, "find: cannot stat %s\n", path);
+        close(fd);
+        return;
+    }
+
+
+    switch (st.type) {
+
+        case T_FILE:// 如果是文件，检查文件名是否匹配
+            if (strcmp(fmtname(path), target) == 0) {
+                printf("%s\n", path);
+            }
+            break;
+
+        case T_DIR://是目录
+            if (strcmp(fmtname(path), target) == 0) {
+                printf("%s\n", path);
+            }
+            if (strlen(path) + 1 + DIRSIZ + 1 > sizeof(buf)) {
+                printf("find: path too long\n");
+            }
+
+            strcpy(buf, path);  // 复制当前路径
+            p = buf + strlen(buf);
+            *p++ = '/';
+
+            // 读取当前目录中的每个文件或子目录
+            while (read(fd, &de, sizeof(de)) == sizeof(de)) {
+                if (de.inum == 0)  // 跳过空目录项
+                    continue;
+                // 跳过 "." 和 ".."
+                if (strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0)
+                    continue;
+                // 构建子路径
+                memmove(p, de.name, DIRSIZ);
+                p[DIRSIZ] = 0;
+                // 获取子路径的状态
+                if (stat(buf, &st) < 0) {
+                    printf("find: cannot stat %s\n", buf);
+                    continue;
+                }
+                // 递归进入子目录或检查文件
+                find(buf, target);
+            }
+        break;
+        }
+    close(fd);
+}
+
+int main(int argc, char *argv[]) {
+    if (argc != 3) {
+        fprintf(2, "Usage: find <path> <name>\n");
+        exit(1);
+    }
+
+    // 从指定路径开始查找目标文件或目录
+    find(argv[1], argv[2]);
+
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..2fc4e4a
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,54 @@
+#include "kernel/types.h"
+#include "user.h"
+
+int main(int argc,char* argv[])
+{
+    int c2f[2];// 子进程 -> 父进程管道
+    int f2c[2];// 父进程 -> 子进程管道
+
+    // 创建两个管道
+    pipe(c2f);
+    pipe(f2c);
+
+    int parent_pid = getpid();
+    int child_pid = fork();  // 创建子进程
+    
+    //printf("parent:%d,child:%d\n",parent_pid,child_pid);
+
+    if(child_pid>0)//父进程
+    {
+        close(f2c[0]);//关闭父进程的读端
+        close(c2f[1]);//关闭子进程的写端
+
+        char *msg = "ping";
+        write(f2c[1], msg, 4);  // 向子进程发送 "ping"
+        close(f2c[1]);  // 关闭父进程写端
+
+        // 父进程读取子进程的响应
+        char buf[5];
+        read(c2f[0], buf, 4);  // 从子进程读取 "pong"
+        buf[4] = '\0';  // 确保字符串以 NULL 结尾
+        printf("%d: received %s from pid %d\n", parent_pid, buf, child_pid);
+        close(c2f[0]);  // 关闭子进程读取端
+
+        wait(0);  // 等待子进程结束
+    }
+    else if(child_pid==0)
+    {
+        close(f2c[1]);//关闭父进程写端
+        close(c2f[0]);//关闭子进程读端
+
+        char buf[5];
+        read(f2c[0], buf, 4);  // 从父进程读取 "ping"
+        buf[4] = '\0';  // 确保字符串以 NULL 结尾
+        printf("%d: received %s from pid %d\n", getpid(), buf, parent_pid);
+
+        // 子进程向父进程发送 "pong"
+        char *msg = "pong";
+        write(c2f[1], msg, 4);
+        close(f2c[0]);  // 关闭读取端
+        close(c2f[1]);  // 关闭写端
+    }
+
+	exit(0);
+}
\ No newline at end of file
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..11e20bb
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,14 @@
+#include "kernel/types.h"
+#include "user.h"
+
+int main(int argc,char* argv[])
+{
+	if(argc !=2){
+		printf("Sleep needs one argument!\n");
+		exit(-1);
+	}
+	int ticks=atoi(argv[1]);
+	sleep(ticks);
+	printf("(nothing happens for a little while)\n");
+	exit(0);
+}
